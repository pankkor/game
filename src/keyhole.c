// Keys and Keyholes screensaver.
// Keys and Keyholes flying around and collingind.
// Matching keys and keyholes dissapear.
//
// Platforms
//   macOS AArch64
// Build
//   ./build.sh
// Run
//   ./build/peeker

#include "common.h"

// --------------------------------------
// Config
// --------------------------------------
// Fixed simulation tick time, s.
#define SIM_TICK          (1.0f / 120.0f)
#define SPRITE_VEL_MAX    0.5f
#define SPRITE_SIZE       0.2f
#define SPRITE_SIZE_05    (SPRITE_SIZE * 0.6f)
#define SPRITE_SCALE_VEL  0.1f

enum {SPRITES_COUNT = 32};

enum sprite_flag : u16 {
  // Flags
  SPRITE_STATE_MOVE       = 1 << 1,
  SPRITE_STATE_SCALE      = 1 << 2,
  SPRITE_STATE_COLLIDE    = 1 << 3,
  SPRITE_STATE_FADE_IN    = 1 << 4,
  SPRITE_STATE_FADE_OUT   = 1 << 5,
  SPRITE_STATE_KEY        = 1 << 6, // 0 - KEYHOLE, 1 - KEY
};

struct sprite_state {
  enum sprite_flag flags;
  i8               palette;
};

enum game_state {
  GAME_STATE_FADE_OUT         = 1 << 1,
  GAME_STATE_SPRITES_FADE_IN  = 1 << 2,
};

#define RGBA_F32x4(hex) {                                                      \
  ((hex & 0xFF000000) >> 24) / 255.0f,                                         \
  ((hex & 0x00FF0000) >> 16) / 255.0f,                                         \
  ((hex & 0x0000FF00) >> 8)  / 255.0f,                                         \
  ((hex & 0x000000FF) >> 0)  / 255.0f,                                         \
}

enum {PALETTE_COUNT = 4};
static const f32 s_col_palettes[PALETTE_COUNT][4] = {
  RGBA_F32x4(0x540D6EFF),
  RGBA_F32x4(0xEE4266FF),
  RGBA_F32x4(0xFFD23FFF),
  RGBA_F32x4(0x38CEACFF),
};

struct sprites {
  ALIGNED(16) f32                 pos       [3 * SPRITES_COUNT]; // update, draw
  ALIGNED(16) f32                 vel       [2 * SPRITES_COUNT]; // update
  ALIGNED(16) f32                 col       [4 * SPRITES_COUNT]; // update, draw
  ALIGNED(16) i32                 tile      [2 * SPRITES_COUNT]; // update, draw
  ALIGNED(16) f32                 scale     [2 * SPRITES_COUNT]; // update, draw
  ALIGNED(16) i32                 palette   [1 * SPRITES_COUNT]; // update
  ALIGNED(16) struct sprite_state state     [1 * SPRITES_COUNT]; // update
};

struct sprites s_sprites;

// --------------------------------------
// GLSL
// --------------------------------------
static const char * const s_sprite_vert_src = "                                \
#version 410 core                                                              \
layout(location = 0) in vec4  v_vertuv;                                        \
layout(location = 1) in vec3  v_pos;                                           \
layout(location = 2) in vec4  v_col;                                           \
layout(location = 3) in vec2  v_scale;                                         \
layout(location = 4) in ivec2 v_tile;                                          \
                                                                               \
uniform float iaspect;                                                         \
uniform ivec2 tiles_count;                                                     \
                                                                               \
out vec4 f_col;                                                                \
out vec2 f_uv;                                                                 \
                                                                               \
void main(void) {                                                              \
  vec3 pos = vec3(v_vertuv.xy * v_scale.xy, 0.0) + v_pos;                      \
  pos.x *= iaspect;                                                            \
  gl_Position = vec4(pos, 1.0);                                                \
  f_col = v_col;                                                               \
  vec2 tile_off_uv = vec2(v_tile) / tiles_count;                               \
  f_uv = v_vertuv.zw + tile_off_uv;                                            \
}                                                                              \
";

static const char * const s_sprite_frag_src = "                                \
#version 410 core                                                              \
in vec4 f_col;                                                                 \
in vec2 f_uv;                                                                  \
                                                                               \
uniform sampler2D mask_tx;                                                     \
                                                                               \
out vec4 frag_col;                                                             \
                                                                               \
void main(void) {                                                              \
    vec2 ra = texture(mask_tx, f_uv).rg;                                       \
    frag_col = vec4(f_col.rgb * ra.r, 1.0f - f_col.a * ra.g);                  \
}                                                                              \
";

enum {
  TILE_W = 32,
  TILE_H = 32,
};

enum {
  TILES_X_COUNT = 1,
  TILES_Y_COUNT = 2,
};

enum {
  MASK_W = TILE_W * TILES_X_COUNT,
  MASH_H = TILE_H * TILES_Y_COUNT,
};

#define TILE_U (1.0f / TILES_X_COUNT)
#define TILE_V (1.0f / TILES_Y_COUNT)

// 32x32 RG8 sprites:
// #0 keyhole u[0.0, 1.0), v[0.0, 0.5)
// #1 key     u[0.0, 1.0), v[0.5, 1.0)
static u16 s_mask_data[MASK_W * MASH_H] = {
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0x80FF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0x80FF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0x80FF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0x80FF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x0000,
  0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0x80FF,
  0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF,
  0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF,
  0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xFF80, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xFF80, 0xFF80, 0xCCFF, 0x80FF,
  0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0xCCFF, 0xFF80, 0xCCFF, 0x80FF, 0x80FF, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xCCFF, 0x80FF,
  0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xCCFF, 0x80FF,
  0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xCCFF, 0xCCFF, 0x80FF, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xCCFF, 0x80FF,
  0x0000, 0x0000, 0x80FF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0x80FF, 0x80FF, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0x80FF,
  0x0000, 0x0000, 0x0000, 0x80FF, 0xCCFF, 0xCCFF, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xCCFF, 0xCCFF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0x80FF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0xCCFF, 0x80FF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x80FF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
};

// --------------------------------------
// Entry point (aka main)
// --------------------------------------
void start(void) {
  // Init
  CGLError cgl_err;
  struct window w = init_window(0 /*is_full_screen*/);

  const GLubyte* version_cstr = glGetString(GL_VERSION);
  print_cstr(STDOUT, "OpenGL version: \n");
  print_cstr(STDOUT, (const char *)version_cstr);
  print_cstr(STDOUT, "\n\n");
  print_cstr(STDOUT, "<Press Ctrl-C to exit>\n");

  GLuint sprite_prog = create_gl_shader_program(
    s_sprite_vert_src,
    s_sprite_frag_src
  );

  f32 aspect  = w.rect[2] / w.rect[3];
  f32 iaspect = 1.0f / aspect;

  GLuint vao;
  GLuint vert_bo;
  GLuint pos_bo;
  GLuint col_bo;
  GLuint scale_bo;
  GLuint tile_bo;
  glGenVertexArrays(1, &vao);
  glGenBuffers(1, &vert_bo);
  glGenBuffers(1, &pos_bo);
  glGenBuffers(1, &col_bo);
  glGenBuffers(1, &scale_bo);
  glGenBuffers(1, &tile_bo);

  GLfloat sprite_verts[] = {
    -SPRITE_SIZE_05, -SPRITE_SIZE_05, 0.0f,   TILE_V,
     SPRITE_SIZE_05, -SPRITE_SIZE_05, TILE_U, TILE_V,
    -SPRITE_SIZE_05,  SPRITE_SIZE_05, 0.0f,   0.0f,
     SPRITE_SIZE_05,  SPRITE_SIZE_05, TILE_U, 0.0f,
  };

  glUseProgram(sprite_prog);
  glBindVertexArray(vao);

  // Vertices
  glBindBuffer(GL_ARRAY_BUFFER, vert_bo);
  glBufferData(GL_ARRAY_BUFFER, sizeof(sprite_verts), sprite_verts,
      GL_STATIC_DRAW);
  glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0);
  glEnableVertexAttribArray(0);

  GLuint mask_tx;
  glGenTextures(1, &mask_tx);
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, mask_tx);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RG, MASK_W, MASH_H, 0,
      GL_RG, GL_UNSIGNED_BYTE, s_mask_data);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

  glUniform1i(glGetUniformLocation(sprite_prog, "mask_tx"), 0);
  glUniform1f(glGetUniformLocation(sprite_prog, "iaspect"), iaspect);
  glUniform2i(glGetUniformLocation(sprite_prog, "tiles_count"),
      TILES_X_COUNT, TILES_Y_COUNT);

  glBindBuffer(GL_ARRAY_BUFFER, pos_bo);
  glBufferData(GL_ARRAY_BUFFER, sizeof(s_sprites.pos), s_sprites.pos,
      GL_STATIC_DRAW);
  glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, 0);
  glVertexAttribDivisor(1, 1);
  glEnableVertexAttribArray(1);

  glBindBuffer(GL_ARRAY_BUFFER, col_bo);
  glBufferData(GL_ARRAY_BUFFER, sizeof(s_sprites.col), s_sprites.col,
      GL_STATIC_DRAW);
  glVertexAttribPointer(2, 4, GL_FLOAT, GL_FALSE, 0, 0);
  glVertexAttribDivisor(2, 1);
  glEnableVertexAttribArray(2);

  glBindBuffer(GL_ARRAY_BUFFER, scale_bo);
  glBufferData(GL_ARRAY_BUFFER, sizeof(s_sprites.scale), s_sprites.scale,
      GL_STATIC_DRAW);
  glVertexAttribPointer(3, 2, GL_FLOAT, GL_FALSE, 0, 0);
  glVertexAttribDivisor(3, 1);
  glEnableVertexAttribArray(3);

  glBindBuffer(GL_ARRAY_BUFFER, tile_bo);
  glBufferData(GL_ARRAY_BUFFER, sizeof(s_sprites.tile), s_sprites.tile,
      GL_STATIC_DRAW);
  glVertexAttribPointer(4, 2, GL_INT, GL_FALSE, 0, 0);
  glVertexAttribDivisor(4, 1);
  glEnableVertexAttribArray(4);

  // Logic
  // Scale bounds normalized to [-1;1] to match monitor aspect ratio
  f32 bounds[4] = {
    -1.0f * aspect + SPRITE_SIZE_05, 1.0f * aspect - SPRITE_SIZE_05,
    -1.0f          + SPRITE_SIZE_05, 1.0f          - SPRITE_SIZE_05,
  };

  struct xorshift64_state vel_st  = {137382305742834};
  struct xorshift64_state pos_st  = {815936748814573};

  // keyholes
  i32 KEYHOLES_COUNT = SPRITES_COUNT * 0.5f;
  i32 KEYS_COUNT = SPRITES_COUNT - KEYHOLES_COUNT;

  for (i32 idx = 0; idx < KEYHOLES_COUNT; ++idx) {
    i32 i       = idx;
    f32 kvel0   = xorshift64(&vel_st) / (f32)U64_MAX;
    f32 kvel1   = xorshift64(&vel_st) / (f32)U64_MAX;
    f32 k       = (f32)(idx + 0.5f) / KEYHOLES_COUNT;
    i32 palette  = idx % PALETTE_COUNT;

    s_sprites.pos[i * 3 + 0]          = bounds[3];
    s_sprites.pos[i * 3 + 1]          = lerpf32(k, bounds[2], bounds[3]);

    s_sprites.pos[i * 3 + 2]          = (f32)i / SPRITES_COUNT;

    s_sprites.vel[i * 2 + 0]  = lerpf32(kvel0, -SPRITE_VEL_MAX, SPRITE_VEL_MAX);
    s_sprites.vel[i * 2 + 1]  = lerpf32(kvel1, -SPRITE_VEL_MAX, SPRITE_VEL_MAX);

    s_sprites.col[i * 4 + 0]            = s_col_palettes[palette][0];
    s_sprites.col[i * 4 + 1]            = s_col_palettes[palette][1];
    s_sprites.col[i * 4 + 2]            = s_col_palettes[palette][2];
    s_sprites.col[i * 4 + 3]            = s_col_palettes[palette][3];

    s_sprites.tile[i * 2 + 0]           = 0;
    s_sprites.tile[i * 2 + 1]           = 0;

    s_sprites.scale[i * 2 + 0]          = 1.0f;
    s_sprites.scale[i * 2 + 1]          = 1.0f;

    s_sprites.state[i * 1 + 0].palette  = palette;
    s_sprites.state[i * 1 + 0].flags =
      SPRITE_STATE_COLLIDE | SPRITE_STATE_MOVE | SPRITE_STATE_KEY;
  }

  for (i32 idx = 0; idx < KEYS_COUNT; ++idx) {
    i32 i       = idx + KEYHOLES_COUNT;
    f32 kvel0   = xorshift64(&vel_st) / (f32)U64_MAX;
    f32 kvel1   = xorshift64(&vel_st) / (f32)U64_MAX;
    f32 k       = (f32)(idx + 0.5f) / KEYS_COUNT;
    i32 palette = idx % PALETTE_COUNT;

    s_sprites.pos[i * 3 + 0]          = bounds[0];
    s_sprites.pos[i * 3 + 1]          = lerpf32(k, bounds[2], bounds[3]);
    s_sprites.pos[i * 3 + 2]          = (f32)i / SPRITES_COUNT;

    s_sprites.vel[i * 2 + 0]  = lerpf32(kvel0, -SPRITE_VEL_MAX, SPRITE_VEL_MAX);
    s_sprites.vel[i * 2 + 1]  = lerpf32(kvel1, -SPRITE_VEL_MAX, SPRITE_VEL_MAX);

    s_sprites.col[i * 4 + 0]            = s_col_palettes[palette][0];
    s_sprites.col[i * 4 + 1]            = s_col_palettes[palette][1];
    s_sprites.col[i * 4 + 2]            = s_col_palettes[palette][2];
    s_sprites.col[i * 4 + 3]            = s_col_palettes[palette][3];

    s_sprites.tile[i * 2 + 0]           = 0;
    s_sprites.tile[i * 2 + 1]           = 1;

    s_sprites.scale[i * 2 + 0]          = 1.0f;
    s_sprites.scale[i * 2 + 1]          = 1.0f;

    s_sprites.state[i * 1 + 0].palette  = palette;
    s_sprites.state[i * 1 + 0].flags = SPRITE_STATE_COLLIDE | SPRITE_STATE_MOVE;
  }
  f32 fade_out_a = 0.0f;

  // Game loop
  f32 cpu_timer_freq  = read_cpu_timer_freq();
  f32 icpu_timer_freq = 1.0f / cpu_timer_freq;
  u64 tsc             = read_cpu_timer();

  f32 loop_s          = 0.0f;
  u64 loop_count      = 0;
  f32 print_dt_tsc    = tsc + 5.0f * cpu_timer_freq;

  f32 sim_dt          = 0.0f;

  while (1) {
    // dt bookkeeping
    u64 new_tsc     = read_cpu_timer();
    f32 dt          = (new_tsc - tsc) * icpu_timer_freq;
    tsc             = new_tsc;
    loop_s          += dt;
    loop_count      += 1;

#if 1 // Print average tick time (print could block io)
    if (tsc > print_dt_tsc) {
      f32 avg_dt    = loop_s / loop_count;

      loop_s        = 0.0f;
      loop_count    = 0;
      print_dt_tsc  = tsc + 5.0f * cpu_timer_freq;

      print_cstr(STDOUT, "Average fps: ");
      print_i64(STDOUT, (u64)(1.0f / avg_dt));
      print_cstr(STDOUT, ", dt: ");
      print_i64(STDOUT, (u64)(avg_dt * 1e3));
      print_cstr(STDOUT, "ms (");
      print_i64(STDOUT, (u64)(avg_dt * 1e6));
      print_cstr(STDOUT, "us)\n");
    }
#else
    (void)loop_s;
    (void)loop_count;
    (void)print_dt_tsc;
#endif
    // Update
    // Accumulate passed time and run simulation with fixed `SIM_TICK` dt
    // Yeah, that's not great when we'r CPU bound.
    sim_dt              += dt;
    i32 sim_tick_count  = sim_dt / SIM_TICK;
    sim_dt              = sim_dt - sim_tick_count * SIM_TICK;

    for (i32 sim_tick = 0; sim_tick < sim_tick_count; ++sim_tick) {
      fade_out_a = clampf32(fade_out_a + 1.0f * SIM_TICK, 0.0f, 1.0f);

      for (i32 i = 0; i < SPRITES_COUNT; ++i) {
        struct sprite_state state;
        f32 pos[2];
        f32 vel[2];
        f32 col[4];
        f32 scale[2];
        i32 dmask[2];

        state           = s_sprites.state[i * 1 + 0];
        pos[0]          = s_sprites.pos[i * 3 + 0];
        pos[1]          = s_sprites.pos[i * 3 + 1];
        vel[0]          = s_sprites.vel[i * 2 + 0];
        vel[1]          = s_sprites.vel[i * 2 + 1];
        col[0]          = s_sprites.col[i * 4 + 0];
        col[1]          = s_sprites.col[i * 4 + 1];
        col[2]          = s_sprites.col[i * 4 + 2];
        col[3]          = s_sprites.col[i * 4 + 3];
        scale[0]        = s_sprites.scale[i * 2 + 0];
        scale[1]        = s_sprites.scale[i * 2 + 1];

        if (is_bit_set(state.flags, SPRITE_STATE_MOVE)) {
          pos[0]        += vel[0] * SIM_TICK;
          pos[1]        += vel[1] * SIM_TICK;
          // Change direction on colliding with bounds
          dmask[0]      = pos[0] < bounds[0] || pos[0] > bounds[1];
          dmask[1]      = pos[1] < bounds[2] || pos[1] > bounds[3];
          vel[0]        *= (1 - (dmask[0] << 1));
          vel[1]        *= (1 - (dmask[1] << 1));
          pos[0]        = clampf32(pos[0], bounds[0], bounds[1]);
          pos[1]        = clampf32(pos[1], bounds[2], bounds[3]);
        }

        if (is_bit_set(state.flags, SPRITE_STATE_SCALE)) {
          scale[0]      += SPRITE_SCALE_VEL;
          scale[1]      += SPRITE_SCALE_VEL;
        }

        if (is_bit_set(state.flags, SPRITE_STATE_FADE_IN)) {
          col[3] *= 1.08f;
          if (col[3] >= 1.0f) {
            state.flags &= ~SPRITE_STATE_FADE_IN;
          }
        }

        if (is_bit_set(state.flags, SPRITE_STATE_FADE_OUT)) {
          col[3] *= 0.94f;
          if (col[3] < 0.001f) {
            // Respawn
            f32 kpos0   = xorshift64(&pos_st) / (f32)U64_MAX;
            f32 kpos1   = xorshift64(&pos_st) / (f32)U64_MAX;
            pos[0]      = lerpf32(kpos0, bounds[0], bounds[1]);
            pos[1]      = lerpf32(kpos1, bounds[2], bounds[3]);
            scale[0]    = 1.0f;
            scale[1]    = 1.0f;
            col[0]      = s_col_palettes[state.palette][0];
            col[1]      = s_col_palettes[state.palette][1];
            col[2]      = s_col_palettes[state.palette][2];
            col[3]      = 0.05f;
            state.flags = (state.flags & SPRITE_STATE_KEY) |
              SPRITE_STATE_COLLIDE | SPRITE_STATE_MOVE | SPRITE_STATE_FADE_IN;
          }
        }
        col[3] = clampf32(col[3], 0.0f, 1.0f);

        s_sprites.pos[i * 3 + 0]        = pos[0];
        s_sprites.pos[i * 3 + 1]        = pos[1];
        s_sprites.vel[i * 2 + 0]        = vel[0];
        s_sprites.vel[i * 2 + 1]        = vel[1];
        s_sprites.col[i * 4 + 0]        = col[0];
        s_sprites.col[i * 4 + 1]        = col[1];
        s_sprites.col[i * 4 + 2]        = col[2];
        s_sprites.col[i * 4 + 3]        = col[3];
        s_sprites.scale[i * 2 + 0]      = scale[0];
        s_sprites.scale[i * 2 + 1]      = scale[1];
        s_sprites.state[i * 1 + 0]      = state;
      }

      // Circle collisions
      f32 radii         = SPRITE_SIZE_05 + SPRITE_SIZE_05;
      f32 radii2        = radii * radii;
      f32 match_radii2  = radii * radii * 0.25f;

      for (i32 i = 0; i < SPRITES_COUNT - 1; ++i) {
        struct sprite_state state0;
        f32 pos0[2];
        f32 vel0[2];

        state0    = s_sprites.state[i * 1 + 0];
        pos0[0]   = s_sprites.pos[i * 3 + 0];
        pos0[1]   = s_sprites.pos[i * 3 + 1];
        vel0[0]   = s_sprites.vel[i * 2 + 0];
        vel0[1]   = s_sprites.vel[i * 2 + 1];

        for (i32 j = i + 1; j < SPRITES_COUNT; ++j) {
          struct sprite_state state1;
          f32 pos1[2];
          f32 vel1[2];
          f32 d[2];           // distance between centers
          f32 dunit[2];       // normalized d
          f32 depth;
          f32 dlen;
          f32 dlen2;
          f32 dotdvel0;
          f32 dotdvel1;
          f32 dvel[2];

          state1    = s_sprites.state[j * 1 + 0];
          pos1[0]   = s_sprites.pos[j * 3 + 0];
          pos1[1]   = s_sprites.pos[j * 3 + 1];
          vel1[0]   = s_sprites.vel[j * 2 + 0];
          vel1[1]   = s_sprites.vel[j * 2 + 1];

          if (!is_bit_set(state0.flags, SPRITE_STATE_COLLIDE)) {
            continue;
          }
          if (!is_bit_set(state1.flags, SPRITE_STATE_COLLIDE)) {
            continue;
          }

          d[0]      = pos1[0] - pos0[0];
          d[1]      = pos1[1] - pos0[1];
          dlen2     = d[0] * d[0] + d[1] * d[1];

          if (dlen2 < radii2) {
            // Key and keyhole of the same pelette merge, the rest collide
            b32 match_palettes = state0.palette == state1.palette;
            b32 match_key_and_keyhole = is_bit_set(state0.flags ^ state1.flags,
                SPRITE_STATE_KEY);
            b32 close_to_match = dlen2 < match_radii2;

            if (match_palettes && match_key_and_keyhole) {
              // Matching key and keyhole
              if (close_to_match) {
                s_sprites.state[i * 1 + 0].flags |=   SPRITE_STATE_SCALE;
                s_sprites.state[j * 1 + 0].flags |=   SPRITE_STATE_SCALE;
                s_sprites.state[i * 1 + 0].flags |=   SPRITE_STATE_FADE_OUT;
                s_sprites.state[j * 1 + 0].flags |=   SPRITE_STATE_FADE_OUT;
                s_sprites.state[i * 1 + 0].flags &=   ~SPRITE_STATE_FADE_IN;
                s_sprites.state[j * 1 + 0].flags &=   ~SPRITE_STATE_FADE_IN;
                s_sprites.state[i * 1 + 0].flags &=   ~SPRITE_STATE_COLLIDE;
                s_sprites.state[j * 1 + 0].flags &=   ~SPRITE_STATE_COLLIDE;
                s_sprites.state[i * 1 + 0].flags &=   ~SPRITE_STATE_MOVE;
                s_sprites.state[j * 1 + 0].flags &=   ~SPRITE_STATE_MOVE;
              }
            } else {
              // Collision and repulsion
              // Depth and normal of collision intesection
              dlen     = sqrtf32(dlen2);
              depth    = radii - dlen;
              dunit[0] = d[0] / dlen;
              dunit[1] = d[1] / dlen;

              pos0[0]  += dunit[0] * depth * -0.5;
              pos0[1]  += dunit[1] * depth * -0.5;
              pos1[0]  += dunit[0] * depth *  0.5;
              pos1[1]  += dunit[1] * depth *  0.5;

              // Ellastic collision
              dotdvel0  = dunit[0] * vel0[0] + dunit[1] * vel0[1];
              dotdvel1  = dunit[0] * vel1[0] + dunit[1] * vel1[1];

              dvel[0]   = dunit[0] * (dotdvel1 - dotdvel0);
              dvel[1]   = dunit[1] * (dotdvel1 - dotdvel0);

              vel0[0]   += dvel[0];
              vel0[1]   += dvel[1];
              vel1[0]   -= dvel[0];
              vel1[1]   -= dvel[1];
            }
          }

          s_sprites.pos[i * 3 + 0]        = pos0[0];
          s_sprites.pos[i * 3 + 1]        = pos0[1];
          s_sprites.vel[i * 2 + 0]        = vel0[0];
          s_sprites.vel[i * 2 + 1]        = vel0[1];

          s_sprites.pos[j * 3 + 0]        = pos1[0];
          s_sprites.pos[j * 3 + 1]        = pos1[1];
          s_sprites.vel[j * 2 + 0]        = vel1[0];
          s_sprites.vel[j * 2 + 1]        = vel1[1];
        }
      }
    }

    // Draw
    glClearColor(0.0f, 0.0f, 0.0f, fade_out_a);
    glClear(GL_COLOR_BUFFER_BIT);
    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE_MINUS_SRC_ALPHA, GL_SRC_ALPHA);

    // Draw sprites
    glBindBuffer(GL_ARRAY_BUFFER, pos_bo);
    glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(s_sprites.pos), s_sprites.pos);

    glBindBuffer(GL_ARRAY_BUFFER, col_bo);
    glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(s_sprites.col), s_sprites.col);

    glBindBuffer(GL_ARRAY_BUFFER, scale_bo);
    glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(s_sprites.scale),
        s_sprites.scale);

    glBindBuffer(GL_ARRAY_BUFFER, tile_bo);
    glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(s_sprites.tile), s_sprites.tile);

    glDrawArraysInstanced(GL_TRIANGLE_STRIP, 0, 4, SPRITES_COUNT);
    CHECK_GL_ERROR();

    cgl_err = CGLFlushDrawable(w.glctx); // swap and present
    WARN_IF(cgl_err, "CGLFlushDrawable() failed\n");
  }

  // Shutdown
  glDeleteShader(sprite_prog);

  glDeleteBuffers(1, &vert_bo);
  glDeleteBuffers(1, &pos_bo);
  glDeleteBuffers(1, &col_bo);
  glDeleteBuffers(1, &scale_bo);
  glDeleteBuffers(1, &tile_bo);
  glDeleteVertexArrays(1, &vao);

  shutdown_window(&w);

  exit(0);
}
